/*
 Required Plugins:
  - Environment Injector Plugin
   -- Add `GIT_BRANCH=some/branch` when testing pipeline script directly in Jenkins
   -- Add `PROD_KUBECTL_CONTEXT=myContenxt` where 'mycontext' is the name of the kubectl context to access the production cluster
 Required Credentials:
  - `docker-hub-credentials` : Username and password for docker hub
  - `scm-credentials` : SSH username (git) and private key to access git. Used when testing pipeline script directly in Jenkins
 Required Jobs:
  - `QA-Tests` : Job to execute tests on all components in a QA environment.
 Required Parameters (under "This job is parameterized"):
  - `CleanWorkspace` : Boolean. Default to unchecked.
*/

// Major.minor version
PROJECT_VERSION = '1.0'
DEPLOYMENT_NAME = 'todo-api'
QA_NAMESPACE = 'qa-env'
PROD_NAMESPACE = 'prod-env'
REGISTRY_URL = 'https://igortestacs.azurecr.io'

node {

    def buildEnv;

    stage('Checkout') {

        if (params.CleanWorkspace) {
            echo "Cleaning Workspace"
            deleteDir()
        }

        echo "Checkout project"
        // Checkout source from the same Git repo/branch this Jenkinsfile resides in.
        checkout scm

        // Checkout source from a specific Git repository
        GIT_REVISION = sh (
                script: 'git rev-parse --short HEAD',
                returnStdout: true
        ).trim()

        echo "Checked out git commit ${GIT_REVISION}"

        OLD_IMAGE_VERSION_QA = getCurrentDeploymentVersion(QA_NAMESPACE)
        // OLD_IMAGE_VERSION_PROD = getCurrentDeploymentVersion(PROD_NAMESPACE)
    }

    stage('Param Testing') {
        echo "imageName: ${imageName}"
        echo "imageVersion: ${imageVersion}"
    }
/*
    stage('Deploy to QA') {
        input 'Push to QA?'
        //TODO: Push to production
        OLD_IMAGE_VERSION_QA = getCurrentDeploymentVersion(QA_NAMESPACE)

        deployImage(
            imageTag: "${IMAGE_FULL_VERSION}",
            namespace: "${QA_NAMESPACE}"
        )
    }

    stage('QA Test') {
        echo "Spawning Job to run functional testing on all components in QA environment"
        build job: 'QA-Tests',
            parameters:
                [
                        string(name: 'imageName', value: PROJECT_IMAGE_NAME),
                        string(name: 'imageVersion', value: QA_IMAGE_FULL_VERSION)
                ]

    }*/
/*
    stage('Prod Image Push') {
        echo "Pushing Production-ready tags to docker registry"
        docker.withRegistry("${REGISTRY_URL}", 'docker-hub-credentials') {
            PROD_IMAGE_FULL_VERSION = "${IMAGE_FULL_VERSION}"
            buildEnv.push(PROD_IMAGE_FULL_VERSION)
            buildEnv.push(IMAGE_SEMVER)
            buildEnv.push("latest")
            buildEnv.push("stable")
        }
    }

    stage('Deploy to Prod') {
        input 'Push to Production?'
        //TODO: Push to production
        OLD_IMAGE_VERSION_PROD = getCurrentDeploymentVersion(PROD_NAMESPACE)

        deployImage(
            imageTag: "${IMAGE_FULL_VERSION}",
            namespace: "${PROD_NAMESPACE}"
        )
    }

    stage('Roll back Prod') {
        input 'Roll back Production?'
        deployImage(
            imageTag: "${OLD_IMAGE_VERSION_PROD}",
            namespace: "${PROD_NAMESPACE}"
        )
    }
*/
}

def deployImage(Map attrs) {
    sh("/usr/local/bin/kubectl set image deployment/${DEPLOYMENT_NAME} ${DEPLOYMENT_NAME}=${PROJECT_IMAGE_NAME}:${attrs.imageTag} --namespace=${attrs.namespace}")
}

def getCurrentDeploymentVersion(String namespace) {
    return sh(
        script: "/usr/local/bin/kubectl get deployment/${DEPLOYMENT_NAME} --namespace=${namespace} -o wide | awk '{ if (NR!=1) {print \$8}}' | cut -d ':' -f 2",
        returnStdout: true
    ).trim()
}
